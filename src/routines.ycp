/**
 * File:	include/inetd/routines.ycp
 * Package:	Configuration of inetd
 * Summary:	Miscelanous functions for configuration of inetd.
 * Authors:	Petr Hadraba <phadraba@suse.cz>
 *
 * $Id$
 */

{

textdomain "inetd";

import "Runlevel";

/**
 * Return rpm -q status for inetd package
 * @return rpm -q exit code
 */
global define integer GetInetdInstalled() ``{
    return SCR::Execute(.target.bash, "/bin/rpm -q inetd 2>&1 > /dev/null", []);
}

/**
 * Return rpm -q status for xinetd package
 * @return rpm -q exit code
 */
global define integer GetXinetdInstalled() ``{
    return SCR::Execute(.target.bash, "/bin/rpm -q xinetd 2>&1 > /dev/null", []);
}

/**
 * Return status of inetd service
 * @return Runlevel::ServiceStatus() result
 */
global define integer GetInetdStatus() ``{
    return Runlevel::ServiceStatus("inetd");
}

/**
 * Return status of xinetd service
 * @return Runlevel::ServiceStatus() result
 */
global define integer GetXinetdStatus() ``{
    return Runlevel::ServiceStatus("xinetd");
}

/**
 * Return a modification status
 * @return true if data was modified
 */
global define boolean Modified() ``{
    return Inetd::Modified();
}

/**
 * Abort function
 * @return If AbortFunction not defined, returnes false
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return eval(AbortFunction) == true;
    return false;
}

/**
 * Check for pending Abort press
 * @return true if pending abort
 */
global define boolean PollAbort() ``{
    return UI::PollInput() == `abort;
}

/**
 * If modified, ask for confirmation
 * @return true if abort is confirmed
 */
global define boolean ReallyAbort() ``{
    return !Modified() || UI::ReallyAbortPopup(true);
}

/**
 * Progress::NextStage and Progress::Title combined into one function
 * @param title progressbar title
 */
global define void ProgressNextStage(string title) ``{
    Progress::NextStage();
    Progress::Title(title);
}

/**
 * Determine, if service package is installed. This function requires full configuration
 * (like Inetd::netd_conf) and standalone map with service.
 * @param netd_conf Full configuration
 * @param which service to determine
 * @return symbol `yes if installed, otherwise `no
 */
global define symbol isServiceInstalled(list netd_conf, map which) ``{
    symbol ret = `no;
    foreach(`line, netd_conf, ``{
	if(line["service"]:"" == which["service"]:"!") {
	    if(line["protocol"]:"" == which["protocol"]:"!") {
		if(find(line["server"]:"", which["program"]:"!") != -1) {
		    ret = `yes;
		    return ret;
		}
	    }
	}
    });
    return ret;
}

/**
 * This function merges real xinetd configuration (read by agent) and
 * available services packages generated for SuSE distribution (Inetd::xinetd_packages).
 * This function is automaticaly calld by CreateTableData() if Inetd::configured_service
 * is `xinetd.
 * @param netd_conf not used in this function, but used for isServiceInstalled() call.
 * @param table_data Table data structure used as source data
 * @return list New table data
 */
global define list mergeXinetdConfs(list netd_conf, list table_data) ``{
    //y2milestone("in function mergeXinetdConfs()");
    integer index = 0;
    foreach(`line, Inetd::xinetd_packages, ``{
	if(isServiceInstalled(netd_conf, line) == `no) {
	    index = index + 1;
	    term entry = `item(`id("NI" + index),
		"",                  // Change entry
		/* Translators: This is used for status "Not Installed". Please, make the
		                translation as short as possible. */
		_("NI"),             // Status entry
		line["service"]:"",  // Service
		"",                  // Socket type
		line["protocol"]:"", // Protocol
		"",                  // Wait
		"",                  // User
		line["program"]:"" + " (" + line["package"]:"---" + ")",  // Server
		"");                 // Server/Args
	    table_data = add(table_data, entry);
	}
    });
    return table_data;
}

/**
 * Converts configuration format from agent to table data structures
 * @param netd_conf netd_conf handles whole configuration of configured service
 * @return returnes table data
 */
global define list(term) CreateTableData(list netd_conf) ``{
    list    table_input     = [];
    list    my_table        = [];
    any     status          = false;
    string  status_text     = "";
    string  wait_text       = "";
    integer numberOfEntries = size(netd_conf);

    if (numberOfEntries != 0) {

	foreach(`line, netd_conf, ``{
	    // service must be marked as nondeleted ("deleted" == false or "deleted" not exists)
	    if (lookup(line, "deleted", false) != true) {

		// determine service is enabled (enabled text)
		string changed_text = (lookup(line, "changed", false) == false) ? "" : "X";
		any status = lookup(line, "enabled", true);
		if (status == true) {
		    /* Translators: Service status: On = running, --- = stopped */
		    status_text = _("On");
		}
		else {
		    /* Translators: This string you can leave unchanged */
		    status_text = _("---");
		}
		// determine wait mode (convert to string)
		status = lookup(line, "wait", true);
		if (status == true) {
		    wait_text = "wait";
		}
		else {
		    wait_text = "nowait";
		}
		any service = lookup(line, "service",     "");
		any rpc_ver = lookup(line, "rpc_version", "");
		if (rpc_ver != "") {
		    service = service + "/" + rpc_ver;
		}
		string user_group = lookup(line, "group", "");
		if (user_group == "") {
		    user_group = lookup(line, "user", "");
		}
		else {
		    user_group = lookup(line, "user", "") + "." + user_group;
		}
		// create line for table structure
		term entry = `item(`id(lookup(line, "iid", "0")),
		    changed_text,
		    status_text,
		    service,
		    lookup(line, "socket_type", ""),
		    lookup(line, "protocol", ""),
		    wait_text,
		    user_group,
		    lookup(line, "server", ""),
		    lookup(line, "server_args", ""));
		// add line to table structure
		table_input = add(table_input, entry);
	    };
	});
    }
    //table_input = sort(table_input);
    if (Inetd::configured_service == `xinetd) {
	table_input = mergeXinetdConfs(netd_conf, table_input);
    }
    return table_input;
};

/**
 * Read user names from passwd.
 * It does not get the NIS entries.
 * "+" is filtered out.
 * @return list users
 */
global define list CreateLocalUsersList() ``{
    list(map) passwd   = SCR::Read(.etc.passwd);
    list(string) users = maplist(map entry, passwd, ``(entry["username"]:""));
    users              = sort(filter(string u, users, ``(u != "+")));
    if(Inetd::configured_service == `xinetd) {
	users = add(users, _("--default--"));
    }
    return users;
}

/**
 * Read group names from  group
 * It does not get the NIS entries.
 * "+" is filtered out.
 * @return list groups
 */
global define list CreateLocalGroupsList() ``{
    list(map) group     = SCR::Read(.etc.group);
    list(string) groups = maplist(map entry, group, ``(entry["groupname"]:""));
    groups              = sort(filter(string u, groups, ``(u != "+")));
    // group entry in inetd_conf can be also empty
    groups              = add(groups, _("--default--"));
    return groups;
}

/**
 * Find any service to be enabled
 * If no found, return `no
 * @param ready_conf ready_conf handles whole service configuration (Inetd::netd_conf)
 * @return returnes if found `yes, otherwise `no
 */
global define symbol IsAnyServiceEnabled(list ready_conf) ``{
    any ret = `no;

    foreach(`line, ready_conf, ``{
	if(lookup(line, "deleted", false) == false) {
	    if(lookup(line, "enabled", false) != false) {
		ret = `yes;
	    }
	}
    });
    return ret;
}

/**
 * Reads xinetd defaults (see Inetd::xinetd_defauls for more details)
 * @return list Returnes Inetd::xinetd_defaults
 */
global define list GetXinetdDefaults() ``{
    return SCR::Read(.target.ycp, Directory::datadir + "/all-services.ycp");
}

/**
 * Find map with given `iid' in given list.
 * @param data list with maps to look into for iid
 * @param iid iid to find
 * @return first ocurence of map with iid `iid' in the list
 */
global define map findiidMapinList(list data, string iid) ``{
    integer count = size(data);
    integer i     = 0; // index

    while(i < count) {
	map line = select(data, i, $[]);
	if(line["iid"]:"" == iid)
	    return line;
	i = i + 1;
    }

    return $[];
}

global define string getenv(string environment) ``{
    string command = sformat("echo $%1", environment);
    map result     = SCR::Execute(.target.bash_output, command, []);
    if(result["stdout"]:"" == "")
	return nil;
    else
        return result["stdout"]:"";
}

/* EOF */
}
