/**
 * File:	include/inetd/routines.ycp
 * Package:	Configuration of inetd
 * Summary:	Miscelanous functions for configuration of inetd.
 * Authors:	Petr Hadraba <phadraba@suse.cz>
 *
 * $Id$
 */

{

textdomain "inetd";

import "Inetd";
import "Progress";
import "Runlevel";
import "Directory";
import "Popup";

/**
 * Return rpm -q status for inetd package
 * @return rpm -q exit code
 */
global define integer GetInetdInstalled() ``{
    return SCR::Execute(.target.bash, "/bin/rpm -q inetd 2>&1 > /dev/null", []);
}

/**
 * Return rpm -q status for xinetd package
 * @return rpm -q exit code
 */
global define integer GetXinetdInstalled() ``{
    return SCR::Execute(.target.bash, "/bin/rpm -q xinetd 2>&1 > /dev/null", []);
}

/**
 * Return status of inetd service
 * @return Runlevel::ServiceStatus() result
 */
global define integer GetInetdStatus() ``{
    return Runlevel::ServiceStatus("inetd");
}

/**
 * Return status of xinetd service
 * @return Runlevel::ServiceStatus() result
 */
global define integer GetXinetdStatus() ``{
    return Runlevel::ServiceStatus("xinetd");
}

/**
 * Return a modification status
 * @return true if data was modified
 */
global define boolean Modified() ``{
    return Inetd::Modified();
}

/**
 * Abort function
 * @return If AbortFunction not defined, returnes false
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return eval(AbortFunction) == true;
    return false;
}

/**
 * Check for pending Abort press
 * @return true if pending abort
 */
global define boolean PollAbort() ``{
    return UI::PollInput() == `abort;
}

/**
 * If modified, ask for confirmation
 * @return true if abort is confirmed
 */
global define boolean ReallyAbort() ``{
    return !Modified() || Popup::ReallyAbort(true);
}

/**
 * Progress::NextStage and Progress::Title combined into one function
 * @param title progressbar title
 */
global define void ProgressNextStage(string title) ``{
    Progress::NextStage();
    Progress::Title(title);
}

/**
 * Used for cpmparisons whether the servers match:
 * If server is /usr/sbin/tcpd, consider server_args instead.
 * Then take the firse word (strips arguments or the parenthesized pkg name).
 * Then take the last slash-delimited component.
 * For sparse matching: nil is returned if server is nil
 * (or if server args is nil AND is needed)
 * @param server "server" field of a service
 * @param server_args "server_args" field of a service
 * @return basename of the real server
 */
global define string GetServerBasename (string server, string server_args) ``{
    string result = server;
    // discard tcpd
    if (result == "/usr/sbin/tcpd")
    {
	result = server_args;
    }
    // check nil
    if (result != nil)
    {
	// program only
	result = select (splitstring (result, " \t"), 0, "");
	// basename
	list comp = splitstring (result, "/");
	result = select (comp, size (comp) - 1, "");
    }
    return result;
}

/**
 * Considers the maps as structs and tests
 * some of their fields for equality (conjunctively, short circuit).
 * @param a one struct
 * @param b other struct
 * @param fields list of keys
 * @return Do the maps have all the named fields equal?
 */
global define boolean struct_match (map a, map b, list fields) ``{
    // short circuit: use the _find_ builtin to get the mismatching key
    any mismatch = find (any key, fields,
			 ``( a[key]:nil != b[key]:nil ));
    // mismatch is nil => they match
    return mismatch == nil;
}

/**
 * Considers the maps as structs and tests
 * some of their fields for equality (conjunctively, short circuit).
 * If a key is missing in either of the maps, it is considered as matching.
 * <p> Used when merging autoyast items, to match only those fields that
 * are specified in the profile. There, only one map is sparse.
 * (the profile map)
 * @param a one struct
 * @param b other struct
 * @param fields list of keys
 * @return Do the maps have all named fields that are in both of them equal?
 * @example match: $["a": 1, "b": 2, "c": 3], $["b": 2, "d": 4]
 */
global define boolean struct_match_sparse (map a, map b, list fields) ``{
    // short circuit: use the _find_ builtin to get the mismatching key
    any mismatch = find (any key, fields,
			 ``(
			     ! ( a[key]:nil == b[key]:nil ||
				 !haskey (a, key) ||
				 !haskey (b, key))
			     ));
    // mismatch is nil => they match
    return mismatch == nil;
}

/**
 * Determine, if service package is installed. This function requires full configuration
 * (like Inetd::netd_conf) and standalone map with service.
 * Linear complexity (in the working config)
 * @param netd_conf Full configuration
 * @param which service to determine, a member of default_conf
 * @return match found
 */
global define symbol isServiceMatchPresent (list netd_conf, map s) ``{
    map match = find (map i, netd_conf, ``(
			  struct_match (i, s, ["script", "service",
					       "protocol", "server"])
			  ));
    return match != nil;
}

/**
 * Encapsulates the mess of supporting two netds and loading the
 * defaults on the fly.
 * Needs Inetd::configured_service.
 * @return Inetd::default_conf_(x)inetd["netd_conf"]
 */
global define list GetDefaults () ``{
    Inetd::EnsureDefaultConfLoaded ();
    return Inetd::configured_service == `inetd?
	(Inetd::default_conf_inetd["netd_conf"]:[]):
	(Inetd::default_conf_xinetd["netd_conf"]:[]);
}

/**
 * This function merges real xinetd configuration (read by agent) and
 * available services packages generated for SuSE distribution (Inetd::xinetd_packages).
 * This function is automaticaly calld by CreateTableData() if Inetd::configured_service
 * is `xinetd.

 * Adds those from all-services that do not have a matching
 * (service,protocol,program) one in the working config.
 * Now that we handle also inetd, better(?) ask RPM

 * TODO rename this function, merge it with mWD
 * it really means AddNotInstalled

 * @param netd_conf not used in this function, but used for isServiceInstalled() call.
 * @param table_data Table data structure used as source data
 * @return list New table data
 */
global define list mergeXinetdConfs(list netd_conf, list table_data) ``{
    //y2milestone("in function mergeXinetdConfs()");

    list defaults = GetDefaults ();

    integer index = 0;
    foreach(`line, defaults, ``{
	if(! isServiceMatchPresent (netd_conf, line)) {
	    index = index + 1;
	    term entry = ServiceToTableItem (line, index);
	    table_data = add(table_data, entry);
	}
    });
    return table_data;
}

/**
 * @param service @ref service
 * @param ni_index if nil, use iid as id, otherwise "NI"+ni_index
 * @return main table item
 */
global define term ServiceToTableItem (map service, integer ni_index) ``{
    y2debug ("* %1", service["service"]:"");
    string  status_text     = "";
    string  wait_text       = "";

    // determine service is enabled (enabled text)
    string changed_text = (service["changed"]:false) ? "X" : "";
    if (service["enabled"]:true) {
	/* Translators: Service status: On = running, --- = stopped */
	status_text = _("On");
    }
    else {
	/* Translators: This string you can leave unchanged */
	status_text = _("---");
    }

    // HACK:
    // Only distinguish non-installed packages for xinetd, like before.
    // No time to do it also for inetd.
    // LATER move this to the new isInstalled function or its ui part
    if (Inetd::configured_service == `xinetd && ni_index != nil)
    {
	/* Translators: This is used for status "Not Installed".
	   Please, make the
	   translation as short as possible. */
	status_text = _("NI");
    }

    // determine wait mode (convert to string)
    if (service["wait"]:true) {
	wait_text = "wait";
    }
    else {
	wait_text = "nowait";
    }
    string sname = service["service"]:"";
    string rpc_ver = service["rpc_version"]:"";
    if (rpc_ver != "") {
	sname = sname + "/" + rpc_ver;
    }
    string user_group = service["group"]:"";
    if (user_group == "") {
	user_group = service["user"]:"";
    }
    else {
	user_group = service["user"]:"" + "." + user_group;
    }
    // create line for table structure
    term entry = `item(
	`id (
	    ni_index == nil ?
	    (service["iid"]:"0") :
	    "NI" + ni_index
	    ),
	changed_text,
	status_text,
	sname,
	service["socket_type"]:"",
	service["protocol"]:"",
	wait_text,
	user_group,
	service["server"]:"",
	service["server_args"]:"");
    return entry;
}

/**
 * Converts configuration format from agent to table data structures
 * @param netd_conf netd_conf handles whole configuration of configured service
 * @return returnes table data
 */
global define list(term) CreateTableData(list netd_conf) ``{
    list    table_input     = [];

    foreach(map service, netd_conf, ``{
	// service must be marked as nondeleted ("deleted" == false or "deleted" not exists)
	if (! service["deleted"]:false) {
	    term entry = ServiceToTableItem (service, nil);
	    // add line to table structure
	    table_input = add(table_input, entry);
	};
    });

    // now can do it for both superservers
    // ... not yet
    if (Inetd::configured_service == `xinetd)
    {
	table_input = mergeXinetdConfs(netd_conf, table_input);
    }
    // table_input = find out which are installed
    // but that would require a better data model.
    // let's try doing with the current one.
    return table_input;
}

/**
 * Read user names from passwd.
 * It does not get the NIS entries.
 * "+" is filtered out.
 * @return list users
 */
global define list CreateLocalUsersList() ``{
    list(map) passwd   = SCR::Read(.etc.passwd);
    list(string) users = maplist(map entry, passwd, ``(entry["username"]:""));
    users              = sort(filter(string u, users, ``(u != "+")));
    if(Inetd::configured_service == `xinetd) {
	users = add(users, _("--default--"));
    }
    return users;
}

/**
 * Read group names from  group
 * It does not get the NIS entries.
 * "+" is filtered out.
 * @return list groups
 */
global define list CreateLocalGroupsList() ``{
    list(map) group     = SCR::Read(.etc.group);
    list(string) groups = maplist(map entry, group, ``(entry["groupname"]:""));
    groups              = sort(filter(string u, groups, ``(u != "+")));
    // group entry in inetd_conf can be also empty
    groups              = add(groups, _("--default--"));
    return groups;
}

/**
 * Find any service to be enabled
 * If no found, return `no
 * @param ready_conf ready_conf handles whole service configuration (Inetd::netd_conf)
 * @return returnes if found `yes, otherwise `no
 */
global define symbol IsAnyServiceEnabled(list ready_conf) ``{
    any ret = `no;

    foreach(`line, ready_conf, ``{
	if(lookup(line, "deleted", false) == false) {
	    if(lookup(line, "enabled", false) != false) {
		ret = `yes;
	    }
	}
    });
    return ret;
}

/**
 * Reads xinetd defaults (see Inetd::xinetd_defauls for more details)
 * @return list Returnes Inetd::xinetd_defaults
 */
global define list GetXinetdDefaults() ``{
    return SCR::Read(.target.ycp, Directory::datadir + "/all-services.ycp");
}

/**
 * Do the services match?
 * Considered fields:
 * "script", "service", "protocol", "server" (or "server_args", if tcpd)
 * The matching is sparse: a missing field in either map
 * means the field is condidered as matching.
 * @param a one map
 * @param b other map
 * @return match?
 */
global define boolean ServicesMatch (map a, map b) ``{
    if (struct_match_sparse (a, b, ["script", "service", "protocol"]))
    {
	// Compare whether the server matches
	// Watch out for tcpd, use basenames
	// because the 8.2 UI produced server="in.ftpd (ftpd)"
	string a_serverbn = GetServerBasename (a["server"]:nil,
					       a["server_args"]:nil);
	string b_serverbn = GetServerBasename (b["server"]:nil,
					       b["server_args"]:nil);
	if (a_serverbn == nil ||
	    b_serverbn == nil ||
	    a_serverbn == b_serverbn)
	{
	    return true;
	}
    }
    return false;
}

/**
 * Get contents of environment variable.
 * @param environment name of requested variable
 * @return environment variable contents
 */
global define string getenv(string environment) ``{
    string command = sformat("echo $%1", environment);
    map result     = SCR::Execute(.target.bash_output, command, []);
    if(result["stdout"]:"" == "")
	return nil;
    else
	return result["stdout"]:"";
}

/* EOF */
}
