/**
 * File:	modules/Inetd.ycp
 * Package:	Configuration of inetd
 * Summary:	Data for configuration of inetd, input and output functions.
 * Authors:	Petr Hadraba <phadraba@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of inetd.
 * Input and output routines.
 */

{

    /**
     * @struct service
     * <pre>
     * A service map looks like this:
     * $[
     ** as seen on TV^H^H (x)inetd.conf:
     *   "service": string      // * different from equally named field above
     *   "rpc_version": string
     *   "socket_type": string
     *   "protocol": string
     *   "wait": boolean
     *   "max": integer         // inetd only
     *   "user": string         // *
     *   "group": string
     *   "server": string
     *   "server_args": string
     *   "comment": string      // possibly multiline, without #
     *   "enabled": boolean     // service is active
     ** bookkeeping fields:
     *   "iid": string          // internal id, use as table `id
     *                          //   Iid is necessary because there may be multiple variants
     *                          //   of the same service. See next for iid handling.
     *   "changed": boolean     // when writing, unchanged services are ignored
     *                          //   new services (created) must be set as changed
     *                          //   see changeLine() and see addLine() for more details
     *   "deleted": boolean     // when deleting, this is set to TRUE and changed
     *                          // must be set too (see deleteLine())
     *   "script": string	// which configuration file this comes from
     *   "package": string	// which rpm it is in
     ** other fields:
     * When handling existing maps, take care to preserve any other fields
     * that may be present!
     *
     *  "unparsed": string	// what the agent could not parse
     * ]
     *
     * path netd = .whatever.inetd or .whatever.xinetd;
     *
     * SCR::Read (.etc.inetd_conf.services) -> list of inetd configuration
     * SCR::Read (.etc.xinetd_conf.services) -> list of xinetd configuration
     * SCR::Write (.etc.inetd_conf.services, list) -> boolean
     * SCR::Write (.etc.xinetd_conf.services, list) -> boolean
     *
     * "iid" handling:
     * The agent (ag_netd) uses it to locate the service in the config
     * files.  Its value should be considered opaque, except that
     * ag_netd will check whether it contains a colon (:) and if not,
     * consider it a new service.
     * Thus new services get "new"+number.
     * Non-installed services:
     *   in normal ui they appear only in the table and get "NI"+number
     *   in autoyast ui they get "inst"+number
     * Where number is last_created
     * </pre>
     * @see <a href="../autoyast_proto.xhtml">autoyast docs</a>.
     */

module "Inetd";
textdomain "inetd";

import "Runlevel";
import "Progress";
import "Report";
import "Summary";
import "Directory";

global define void EnsureDefaultConfLoaded ();
global define list mergeAfterInstall(list system_c, list user_c);
global define list MergeAyProfile (list target, list changes);

/**
 * What service is in configuration process?
 * Same values as netd_service except `both
 */
global symbol configured_service = `none;

/**
 * Default configuration for inetd (all services in the distro)
 */
global map default_conf_inetd = nil;

/**
 * Default configuration for xinetd (all services in the distro)
 */
global map default_conf_xinetd = nil;

/**
 * Abort function
 * return boolean return true if abort
 */
global block<boolean> AbortFunction = nil;

global define boolean Modified();

include "inetd/routines.ycp";

/**
 * Abort function
 * @return If AbortFunction not defined, returnes false
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return eval(AbortFunction) == true;
    return false;
}

/**
 * Configuration was changed
 */
global boolean modified = false;

/**
 * used in unused module inetd_proposal.ycp. This will be removed
 */
global boolean proposal_valid = false;

/**
 * For autoinstallation Write() process.
 * Write_only means that the service will not be actually started,
 * because it is done by init later.
 * But also that the service data are only a patch to be applied to the system.
 */
global boolean write_only = false;

/**
 * If autoinstallation mode (true), we do not want to install RPMs during configuration.
 * Otherwise (false) we allow all.
 */
global boolean auto_mode = false;

/**
 * Data was modified? This function returnes modified variable.
 * @return true if modified
 */
global define boolean Modified() ``{
    //y2debug("modified=%1",modified);
    return modified;
};

/**
 * hold informations about installed services (rpm -q exit code).
 * 0 means installed, anything else means no or error
 * <br>
 * inetd_installed  contains info about inetd
 */
global integer inetd_installed   = -1;

/**
 * xinetd_installed contains info about xinetd
 */
global integer xinetd_installed  = -1;

/**
 * What service is ready for configuration?
 * <br> `none   means no available --- this is for AutoInstallation
 * <br> `both   means the selection dialog will be displayed (only one service can run)
 * <br> `inetd  inetd will be configured
 * <br> `xinetd xinetd will be configured
 * <br> in autoinst used in the sense of configured_service???
 * @see configured_service
 */
global symbol netd_service       = `none;

/**
 * <pre>
 * These variable holds inetd configuration.
 * This is list of maps. Each map has the following structure:
 *   $[
 *     "comment": String,
 *     "comment_inside": String, // this is agent internal
 *     "enabled": boolean,
 *     "group": String,
 *     "user": String,
 *     "iid": String,
 *     "protocol": String,
 *     "rpc_version": String,
 *     "server": String,
 *     "server_args": String,
 *     "service": String,
 *     "socket_type": String,
 *     "unparsed": String,       // agent internal
 *     "wait": boolean
 *  ]
 * </pre>
 */
global list inetd_conf           = [];

/**
 * This variable holds xinetd configuration.
 * The structure is the same as inetd_conf.
 */
global list xinetd_conf          = [];

/**
 * Holds configuration of selected service (service in configuration process).
 * The name of this service is stored in configured_service.
 * Structure of this variable is the same as inetd_conf or xinetd_conf.
 */
global list netd_conf            = [];

/**
 * Holds default configuration for currently edited superserver.
 */
global map default_conf          = $[];

/**
 * Is inetd (or xinetd) running?
 * These variables contains return values from Runlevel::ServiceStatus() calls.
 */
global integer inetd_status      = -1;

/**
 * This contains return value of following call:
 * <br>  Runlevel::ServiceStatus("xinetd");
 */
global integer xinetd_status     = -1;

/**
 * Status of edited service (see WhatToConfigureDialog() in dialogs.ycp)
 * Values are the same as (x)inetd_status.
 */
global integer netd_status       = -1;

/**
 * Status of inetd module if autoinstallation mode.
 * Used in Summary.
 * This is the state of whole module. This variable is filled by Import().
 * Possible values are <br> `configured     --- imported configuration data are valid
 *                     <br> `not_configured --- configuration data are invalid
 */
global symbol module_status      = `not_configured;

/**
 * This variable is used for new iid "generator"
 */
global integer last_created      = 0;

/**
 * Read default_conf_{inetd,xinetd}, if not already done
 */
global define void EnsureDefaultConfLoaded () ``{
     if (default_conf_inetd == nil)
     {
	 default_conf_inetd = $[
	     "netd_conf": SCR::Read (.target.ycp, Directory::datadir + "/default_conf_inetd.ycp"),
	     "netd_service": `inetd,
	     "netd_status": -1,
	     ];
     }
     if (default_conf_xinetd == nil)
     {
	 default_conf_xinetd = $[
	     "netd_conf": SCR::Read (.target.ycp, Directory::datadir + "/default_conf_xinetd.ycp"),
	     "netd_service": `xinetd,
	     "netd_status": -1,
	     ];
     }
 }

/**
 * Read all inetd settings
 * @return true on success
 */
global define boolean Read() ``{

    /* Inetd read dialog caption */
    string caption = _("Initializing inetd Configuration");

    integer steps = 1;

    integer sl = 0;
    sleep(sl);

    Progress::New( caption, " ", steps, [
	    _("Read the Configuration"),
	], [
	    _("Reading the configuration..."),
	    _("Finished")
	],
	""
    );

    integer read_status = 0;
    // read database
    if(Abort()) return false;

    if(netd_service == `none)
	return false;

    if(netd_service == `both) {
	inetd_conf  = (list) SCR::Read(.etc.inetd_conf.services);
	xinetd_conf = (list) SCR::Read(.etc.xinetd_conf.services);
    }
    else if(netd_service == `inetd) {
	inetd_conf = (list) SCR::Read(.etc.inetd_conf.services);
    }
    else if(netd_service == `xinetd) {
	xinetd_conf = (list) SCR::Read(.etc.xinetd_conf.services);
    }

    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    Progress::Finish();
    return true;
}

/**
 * This function solves differences between new
 * (after installing requested packages)
 * xinetd configuration and the configuration edited by the user.
 * <pre>
 * <b>In normal mode</b>:
 * take the system services
 *   if it matches a service in the ui (ServicesMatch)
 *     use the ui data
 * (not-installed ones are not a part of netd_conf, they
 * only enter the table in mergexinetdconfs)
 * Deleted services: OK.
 * Added services: a separate pass needed
 * </pre>
 * TODO reduce the quadratic complexity.
 * @param system_conf holds new configuration (on the system)
 * @param edited_conf holds old configuration (UI)
 * @return list Returnes new solved xinetd configuration (ready for Write()).
 */
global define list MergeEditedWithSystem (list system_conf, list edited_conf) ``{
    map new_entry = nil;

    // Take system services as the basis
    // (they include the newly installed ones)
    // and replace most of them with their edited counterparts
    // that also takes care of deleted services
    // but not of added ones
    system_conf = maplist(map<string, any> system_s, system_conf, ``{
	new_entry = system_s;
	foreach(map<string, any> edited_s, edited_conf, ``{
	    if (ServicesMatch (system_s, edited_s))
	    {
		new_entry = edited_s;
	    }
	});
	return new_entry;
    });

    // now the added services
    list added = filter (map edited_s, edited_conf,
			 ``( find (edited_s["iid"]:"", "new") == 0 ));
    return flatten ([system_conf, added]);
}

/**
 * Write all inetd settings
 * @return true on success
 */
global define boolean Write() ``{

    /* Inetd read dialog caption */
    string caption = _("Saving inetd Configuration");

    integer steps = 1;

    integer sl = 0;
    sleep(sl);

    Progress::New(caption, " ", steps, [
	    _("Write the settings"),
	], [
	    _("Writing the settings..."),
	    _("Finished")
	],
	""
    );

    y2milestone("Calling write:\n");
    // write settings
    if(Abort()) return false;
    if (write_only) {
	list new_conf = [];
	if (configured_service == `inetd) {
	    if (netd_status == 0) {
		Runlevel::ServiceAdjust("inetd", "enable");
	    }
	    else {
		Runlevel::ServiceAdjust("inetd", "disable");
	    }
	    Runlevel::ServiceAdjust("xinetd", "disable");
	    SCR::Write(.etc.inetd_conf.services, netd_conf);
	}
	else if (configured_service == `xinetd) {
	    new_conf  = (list) SCR::Read(.etc.xinetd_conf.services);
	    netd_conf = mergeAfterInstall(new_conf, netd_conf);
	    if (netd_status == 0) {
		Runlevel::ServiceAdjust("xinetd", "enable");
	    }
	    else {
		Runlevel::ServiceAdjust("xinetd", "disable");
	    }
	    Runlevel::ServiceAdjust("inetd", "disable");
	    SCR::Write(.etc.xinetd_conf.services, netd_conf);
	}
    }
    else {
	// configured service is inetd
	if (configured_service == `inetd) {
	    // xinetd must be stopped - if installed
	    if (xinetd_installed == 0) {
		y2milestone("xinetd installed  --- stopping and disabling service");
		if (!write_only)
		    Runlevel::RunInitScript("xinetd", "stop");
		Runlevel::ServiceAdjust("xinetd", "disable");
	    }
	    else {
		y2milestone("xinetd not installed --- nothing done");
	    }
	    y2milestone("writing inetd configuration");
	    SCR::Write(.etc.inetd_conf.services, netd_conf);
	    // So, Restart service
	    if (netd_status != 0) { // want to stop
		if (inetd_status == 0) { // was running --- stop
		    y2milestone("inetd was running --- stoping and disabling service");
		    if (!write_only)
			Runlevel::RunInitScript("inetd", "stop");
		    Runlevel::ServiceAdjust("inetd", "disable");
		} // else --- leave stopped
		else {
		    y2milestone("inetd was stopped --- leaving unchanged");
		}
	    }
	    else { // want to start
		// if inetd is running - only reload
		if (inetd_status == 0) {
		    y2milestone("inetd was running --- calling force-reload");
		    if (!write_only)
			Runlevel::RunInitScript("inetd", "force-reload");
		}
		// if stopped - enable and start
		else {
		    y2milestone("inetd was stopped --- enabling and starting service");
		    Runlevel::ServiceAdjust("inetd", "enable");
		    if (!write_only)
			Runlevel::RunInitScript("inetd", "start");
		}
	    }
	}
	// configured service is xinetd
	else {
	    // inetd must be stopped - if installed
	    if (inetd_installed == 0) {
		y2milestone("inetd installed     --- stopping and disabling service");
		if (!write_only)
		    Runlevel::RunInitScript("inetd", "stop");
		Runlevel::ServiceAdjust("inetd", "disable");
	    }
	    else {
		y2milestone("inetd not installed --- nothing done");
	    }
	    y2milestone("writing xinetd cnfiguration");
	    SCR::Write(.etc.xinetd_conf.services, netd_conf);
	    // So, Restart service
	    if (netd_status != 0) { // want to stop
		if (xinetd_status == 0) {
		    y2milestone("xinetd was running --- stopping and disabling service");
		    if (!write_only)
			Runlevel::RunInitScript("xinetd", "stop");
		    Runlevel::ServiceAdjust("xinetd", "disable");
		}
		else {
		    y2milestone("xinetd was stopped --- leaving unchanged");
		}
	    }
	    else { // want to start
		// if xinetd is running - only reload
		if (xinetd_status == 0) {
		    y2milestone("xinetd was running --- calling force-reload");
		    if (!write_only)
			Runlevel::RunInitScript("xinetd", "force-reload");
		}
		// if stopped - enable and start
		else {
		    y2milestone("xinetd was stopped --- enabling and starting service");
		    Runlevel::ServiceAdjust("xinetd", "enable");
		    if (!write_only)
			Runlevel::RunInitScript("xinetd", "start");
		}
	    }
	}
    }


    y2milestone("Writting done\n");

    // in future: catch errors
    if(false) Report::Error (_("Cannot write settings!"));
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    Progress::Finish();
    return true;
}

/**
 * Only Write settings
 * @return boolean True on success
 */
global define boolean WriteOnly () ``{
    write_only = true;
    return Write();
}

/**
 * Merges autoinstall profile into the system configuration.
 * @param system_c holds new configuration (on the system)
 * @param user_c  holds old configuration (auto: profile + defaults)
 * @return list Returnes new solved xinetd configuration (ready for Write()).
 * @see MergeAyProfile
 */
global define list mergeAfterInstall(list system_c, list user_c) ``{
    return MergeAyProfile (system_c, user_c);
}

/**
 * merges imported changes with services defaults
 * @param changes imported changes
 * @return complete configuration with user changes
 * @see MergeAyProfile
 */
global define list mergeWithDefaults(list changes) ``{
    list target = default_conf["netd_conf"]:[];
    return MergeAyProfile (target, changes);
}

/**
 * Removes keys from a map. Unlike the remove builtin, does not mind if
 * the keys are already removed.
 * @param m a map
 * @param keys list of keys to remove
 * @return the map without the specified keys
 */
global define map SafeRemove (map m, list keys) ``{
    foreach (any key, keys, ``{
	if (haskey (m, key))
	{
	    m = remove (m, key);
	}
    });
    return m;
}

/**
 * Merges AY profile items into a target list (defaults or system).
 * @param target base list of services
 * @param changes imported changes
 * @return merged list of services
 * @see <a href="../autoyast_proto.xhtml">autoyast docs</a>.
 */
global define list MergeAyProfile (list target, list changes) ``{
    // for each change in the patch list:
    foreach (map<string, any> change_s, changes, ``{
	integer matches = 0;
	// For compatibility and as a hook for workarounds
	// if the matching turns out to be too clever:
	// skip matching
	string change_iid = change_s["iid"]:"";
	if (find (change_iid, "new") == 0
	    /* || find (change_iid, "inst") == 0*/ )
	{
	    // do nothing, matches is 0 and we add the service
	}
	else
	{
	    // apply the change to the target list:
	    target = maplist(map<string, any> target_s, target, ``{
		map new_entry = target_s;
		if (ServicesMatch (change_s, target_s))
		{
		    // yippee, it matches
		    matches = matches + 1;

		    // Cannot do a simple union, because we don't
		    // want to merge the "server" key field:
		    // The "basename (package)" content generated by the
		    // AY UI must be avoided.
		    // And while merging, iid must be also preserved
		    map to_merge = SafeRemove (change_s, ["server", "iid"]);
		    new_entry = union (new_entry, to_merge);
		    new_entry = add (new_entry, "changed", true);
		    // "enabled" is true - if not present
		    new_entry = add (new_entry, "enabled",
				     change_s["enabled"]:true);
		}
		return new_entry;
	    });
	}
	/*
	 * Not found in target? Three states happened:
	 *  - Service is new (user wants forEx. telnet on port #53;-)
	 *  - Service is from non-SuSE package
	 *  - Service name or description is invalid
	 */
	if (matches == 0)
	{
	    target = add(target, change_s);
	}
	else if (matches > 1)
	{
	    y2warning ("Ambiguous match (%1): %2", matches, change_s);
	}
    });

    //y2milestone("%1", changes);
    //y2milestone("%1", target);

    return target;
}

/**
 * Get all inetd settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
    EnsureDefaultConfLoaded ();

    // we do not want to install RPMs in autoinstallation mode...
    auto_mode = true;
    modified  = false;

    if (settings == $[])
	module_status = `not_configured;
    else
	module_status = `configured;

    //y2milestone("settings = %1", settings);
    /*
     * if map contains "netd_service", whole configuration is filled
     * from this map.  if "netd_service" is not found, configuration is
     * generated from default values stored if default_conf_*.ycp.
     */
    // service is inetd
    if (settings["netd_service"]:`none == `inetd) {
	netd_service  = `inetd;
	default_conf  = default_conf_inetd;
	inetd_conf    = mergeWithDefaults(settings["netd_conf"]:[]);
	inetd_status  = 0;
	netd_status   = settings["netd_status"]:-1;
	netd_conf     = inetd_conf;
    }
    // service is xinetd
    else if (settings["netd_service"]:`none == `xinetd) {
	netd_service  = `xinetd;
	default_conf  = default_conf_xinetd;
	xinetd_conf   = mergeWithDefaults(settings["netd_conf"]:[]);
	xinetd_status = 0;
	netd_status   = settings["netd_status"]:-1;
	netd_conf     = xinetd_conf;
    }
    // no service detected --- loading defaults
    else if (settings["netd_service"]:`none == `none) {
	inetd_conf    = default_conf_inetd["netd_conf"]:[];
	xinetd_conf   = default_conf_xinetd["netd_conf"]:[];
	inetd_status  = 0;
	xinetd_status = 0;
	netd_service  = `none;
    }
    // common variables
    last_created       = settings["last_created"]:0;
    configured_service = netd_service;
    //y2milestone("%1", netd_conf);
    return true;
}

/**
 * Get only changed entries
 * @param config complete configuration
 * @return Returnse list of changes only
 */
global define list getChanged(list config) ``{
    list<map> defaults = [];
    list changes  = [];
    map  def_line = $[];

    EnsureDefaultConfLoaded ();
    if(netd_service == `inetd)
	defaults = default_conf_inetd["netd_conf"]:[];
    else
	defaults = default_conf_xinetd["netd_conf"]:[];

    // defaults not loaded --- get all services listed in config
    if(defaults == [])
	return config;

    // Deleted services: so far they are exported
    // But maybe better to allow only deleting added services (~ undo)
    // and thus not export them.
    foreach(map<string, any> line, config, ``{
	// only changed ones...
	if (line["changed"]:false) {
	    // now trim the fields that are not necessary, because
	    // they are a part of the defaults

	    // new or installed services (iid is `^new.*' or `^inst.*')
	    // are not trimmed
	    string line_iid = line["iid"]:"";
	    if (find(line_iid, "new") == 0 || find(line_iid, "inst") == 0) {
		changes = add(changes, line);
		return; // skip the following code
	    }

	    // Find coresponding entry in `defaults'.
	    // Could use iid here because we started editing
	    // with the defaults list
	    // but it broke the testsuite.
	    def_line = find (map<string, any> default_s, defaults, ``(
				 ServicesMatch (line, default_s)
				 ));

	    // item not found
	    // So, write this entry into `changes'
	    if (def_line == nil) {
		changes = add(changes, line);
		return; // skip the following code
	    }

	    // especially for inetd, server must not be tcpd, because
	    // we could trow away the real server which distinguishes
	    // a service among its variants
	    if (line["server"]:"" == "/usr/sbin/tcpd")
	    {
		string s = select (splitstring (line["server_args"]:"", " \t"),
				   0, "");
		line = (map<string, any>) add (line, "server", s);
	    }

	    // for each item of the map
	    foreach(string name, any val, line, ``{
		// Remove it if its value is the default
		// and it's not a key field or "enabled" (*).
		// In particular, iid is trimmed here.
		if (val == def_line[name]:nil &&
		    !contains (["script", "protocol", "service", "server",
				"enabled"], name))

		{
		    line = (map<string, any>) remove(line, name);
		}
	    });

	    // "changed" is implicitly true for all Exported/Imported services
	    line = (map<string, any>) remove (line, "changed");
	    // "enabled" defaults to true in _Import_, so it would
	    // have been wrong above (*) to match it against the
	    // _system_ default of false.
	    if (line["enabled"]:false)
	    {
		line = (map<string, any>) remove (line, "enabled");
	    }

	    changes = add(changes, line);
	}
    });

    //y2milestone("%1", changes);
    return changes;
}

/**
 * Dump the inetd settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
//    sleep(3000);
    map config = $[];
    config = add(config, "netd_conf",       getChanged(netd_conf));
    config = add(config, "netd_service",    configured_service);
    config = add(config, "netd_status",     netd_status);
    config = add(config, "last_created",    last_created);
    y2milestone("%1", config);
    return config;
}

/**
 * Create unsorted list of enabled services
 * @return string Returnes string with RichText-formated list
 */
global define string mkeServiceSummary() ``{
    string S = "";
    foreach(map<string, any> line, netd_conf, ``{
	//"enabled" defaults to true
	if(line["enabled"]:true && !line["deleted"]:false) {
	    S = sformat("%1<li>%2 <i>(%3)</i>",
			S,
			line["service"]:"",
			line["protocol"]:"");
	}
    });
    if(S == "")
	S = _("<p><ul><i>All services are marked as stopped.</i></ul></p>");
    return S;
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define string Summary() ``{
    string S = "";
    if(module_status == `not_configured) {
	/*
	 * Translators: Summary head, if nothing configured
	 */
	S = Summary::AddHeader(S, _("Network services"));
	S = Summary::AddLine(S, Summary::NotConfigured());
    }
    else {
	/*
	 * Translators: Summary head, if something configured
	 */
	string head = sformat(_("Network services are managed via %1"),
	    configured_service == `inetd ? "inetd" : "xinetd");
	S = Summary::AddHeader(S, head);
	S = Summary::AddHeader(S, _("These services will be enabled"));
	S = sformat("%1<ul>%2</ul></p>", S, mkeServiceSummary());
    }
    return S;
}

/**
 * delete line in netd_conf
 * @param line_number "iid" geted from table's item ID
 */
global define void deleteLine(any line_number) ``{
    // delete
    map current_line = (map) select(filter(map<string, any> line, netd_conf,
	``(line["iid"]:"0" == line_number)), 0, $[]);
    // set "deleted" flag to true
    current_line = add(current_line, "changed", true);
    current_line = add(current_line, "deleted", true);
    netd_conf    = maplist(map<string, any> line, netd_conf, ``{
	if (line["iid"]:"0" == line_number) {
	    return(current_line);
	}
	else {
	    return(line);
	}
    });
};

/**
 * add a line in DB
 * @param new_line new_line contains new entry for global netd_conf configuration
 * @return void
 */
global define void addLine(map new_line) ``{
    // add
    new_line  = add(new_line, "changed", true);
    netd_conf = add(netd_conf, new_line);
    return;
}

/**
 * Change a line in DB
 * @param new_line new_line contains changes for entry in netd_conf
 * @param line_number line_number contains iid of changed entry in netd_conf
 */
global define void changeLine(map new_line, any line_number) ``{
    // entry was changed - so set "changed" flag to true
    new_line  = add(new_line, "changed", true);
    netd_conf = maplist(map<string, any> line, netd_conf, ``{
	if (line["iid"]:"0" == line_number) {
	    return(new_line);
	}
	else {
	    return(line);
	}
    });
};
/**
 * Return required packages for auto-installation
 * FIXME: Need to make this return the needed packages during installation
 * @return map of packages to be installed and to be removed
 */
global define map AutoPackages() ``{
	return ($["install": [], "remove": []]);

}

/* EOF */
}
