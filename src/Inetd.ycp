/**
 * File:	modules/Inetd.ycp
 * Package:	Configuration of inetd
 * Summary:	Data for configuration of inetd, input and output functions.
 * Authors:	Petr Hadraba <phadraba@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of inetd.
 * Input and output routines.
 */

{

    /**
     * <pre>
     * New SCR interface:
     * A service map looks like this:
     * $[
     *   "service": string      // * different from equally named field above
     *   "rpc_version": string
     *   "socket_type": string
     *   "protocol": string
     *   "wait": boolean
     *   "max": integer         // inetd only
     *   "user": string         // *
     *   "group": string
     *   "server": string
     *   "server_args": string
     *   "comment": string      // possibly multiline, without #
     *   "enabled": string      // service is active
     ** bookkeeping fields:
     *   "iid": string          // internal id, use as table `id
     *                          //   Iid is necessary because there may be multiple variants
     *                          //   of the same service. See next for iid handling.
     *   "changed": boolean     // when writing, unchanged services are ignored
     *                          //   new services (created) must be set as changed
     *                          //   see changeLine() and see addLine() for more details
     *   "deleted": boolean     // when deleting, this is set to TRUE and changed
     *                          // must be set too (see deleteLine())
     * ]
     * When handling existing maps, take care to preserve any other fields
     * that may be present!
     *
     * path netd = .whatever.inetd or .whatever.xinetd;
     *
     * SCR::Read (.etc.inetd_conf.services) -> list of inetd configuration
     * SCR::Read (.etc.xinetd_conf.services) -> list of xinetd configuration
     * SCR::Write (.etc.inetd_conf.services, list) -> boolean
     * SCR::Write (.etc.xinetd_conf.services, list) -> boolean
     *
     * "iid" handling
     * The standard situation is something like "iid": "1:/etc/xinetd.d/chargen"
     * If user adds new service, inetd module creates new unique iid based on word "new"
     * and incremented number started with "1".
     * The similar situation is, when managing xinetd and service packages are not installed.
     * The "iid" has the same rules, but the word is "inst".
     * </pre>
     */

module "Inetd";
textdomain "inetd";

import "Progress";
import "Report";
import "Summary";
import "Directory";

include "inetd/routines.ycp";
include "inetd/default_conf_inetd.ycp";
include "inetd/default_conf_xinetd.ycp";

/**
 * Abort function
 * return boolean return true if abort
 */
global block AbortFunction = nil;

/**
 * Configuration was changed
 */
global boolean modified = false;

/**
 * used in unused module inetd_proposal.ycp. This will be removed
 */
global boolean proposal_valid = false;

/*
 * For autoinstallation Write() process.
 */
global boolean write_only = false;

/**
 * If autoinstallation mode (true), we do not want to install RPMs during configuration.
 * Otherwise (false) we allow all.
 */
global boolean auto_mode = false;

/**
 * Data was modified? This function returnes modified variable.
 * @return true if modified
 */
global define boolean Modified() ``{
    //y2debug("modified=%1",modified);
    return modified;
};

/**
 * hold informations about installed services (rpm -q exit code).
 * 0 means installed, anything else means no or error
 * <br>
 * inetd_installed  contains info about inetd
 */
global integer inetd_installed   = -1;

/**
 * xinetd_installed contains info about xinetd
 */
global integer xinetd_installed  = -1;

/**
 * What service is ready for configuration?
 * <br> `none   means no available --- this is for AutoInstallation
 * <br> `both   means the selection dialog will be displayed (only one service can run)
 * <br> `inetd  inetd will be configured
 * <br> `xinetd xinetd will be configured
 */
global symbol netd_service       = `none;

/**
 * What service is in configuration process?
 * Same values as netd_service except `both
 */
global symbol configured_service = `none;

/**
 * <pre>
 * These variable holds inetd configuration.
 * This is list of maps. Each map has the following structure:
 *   $[
 *     "comment": String,
 *     "comment_inside": String, // this is agent internal
 *     "enabled": boolean,
 *     "group": String,
 *     "user": String,
 *     "iid": String,
 *     "protocol": String,
 *     "rpc_version": String,
 *     "server": String,
 *     "server_args": String,
 *     "service": String,
 *     "socket_type": String,
 *     "unparsed": String,       // agent internal
 *     "wait": boolean
 *  ]
 * </pre>
 */
global list inetd_conf           = [];

/**
 * This variable holds xinetd configuration.
 * The structure is the same as inetd_conf.
 */
global list xinetd_conf          = [];

/**
 * Holds configuration of selected service (service in configuration process).
 * The name of this service is stored in configured_service.
 * Structure of this variable is the same as inetd_conf or xinetd_conf.
 */
global list netd_conf            = [];

/**
 * Holds package names which provides xinetd services (like ftp, ...).
 * This list is filled by calling routine
 * <pre>  xinetd_packages = SCR::Read(.target.ycp, Directory::datadir + "/all-services.ycp");</pre>
 */
global list xinetd_packages      = [];

/**
 * This variable holds informations about main package (inetd or xinetd)
 * This variable is used in autoinstallation mode.
 */
//global list service_package      = [];

/**
 * Required packages for Autoinstallation write.
 * Contains xinetd services package names (for more details please see xinetd_packages).
 */
//global list required_packages    = [];

/**
 * Is inetd (or xinetd) running?
 * These variables contains return values from Runlevel::ServiceStatus() calls.
 */
global integer inetd_status      = -1;

/**
 * This contains return value of following call:
 * <br>  Runlevel::ServiceStatus("xinetd");
 */
global integer xinetd_status     = -1;

/**
 * Status of edited service (see WhatToConfigureDialog() in dialogs.ycp)
 * Values are the same as (x)inetd_status.
 */
global integer netd_status       = -1;

/**
 * Status of inetd module if autoinstallation mode.
 * This is the state of whole module. This variable is filled by Import().
 * Possible values are <br> `configured     --- imported configuration data are valid
 *                     <br> `not_configured --- configuration data are invalid
 */
global symbol module_status      = `not_configured;

/**
 * This variable is used for new iid "generator"
 */
global integer last_created      = 0;


/**
 * Read all inetd settings
 * @return true on success
 */
global define boolean Read() ``{

    /* Inetd read dialog caption */
    string caption = _("Initializing inetd Configuration");

    integer steps = 1;

    integer sl = 0;
    sleep(sl);

    Progress::New( caption, " ", steps, [
	    _("Read the Configuration"),
	], [
	    _("Reading the configuration..."),
	    _("Finished")
	],
	""
    );

    integer read_status = 0;
    // read database
    if(Abort()) return false;

    if(netd_service == `none)
	return false;

    if(netd_service == `both) {
	inetd_conf  = SCR::Read(.etc.inetd_conf.services);
	xinetd_conf = SCR::Read(.etc.xinetd_conf.services);
    }
    else if(netd_service == `inetd) {
	inetd_conf = SCR::Read(.etc.inetd_conf.services);
    }
    else if(netd_service == `xinetd) {
	xinetd_conf = SCR::Read(.etc.xinetd_conf.services);
    }
    xinetd_packages = SCR::Read(.target.ycp, Directory::datadir + "/all-services.ycp");

    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    Progress::Finish();
    return true;
}

/**
 * This function solves differences between new (after installing requested packages)
 * xinetd configuration and old small configuration created by user.
 * @param netd_conf holds new configuration
 * @param old_conf  holds old configuration
 * @return list Returnes new solved xinetd configuration (ready for Write()).
 */
global define list mergeAfterInstall(list netd_conf, list old_conf) ``{

    map new_entry = nil;

    if(!auto_mode) {
    netd_conf = maplist(`new_line, netd_conf, ``{
	new_entry = new_line;
	foreach(`old_line, old_conf, ``{
	    if((new_line["service"]:"" == old_line["service"]:"!") &&         // service
		(new_line["protocol"]:"" == old_line["protocol"]:"!") &&       // protocol
		(find(new_line["server"]:"", old_line["server"]:"!") != -1)) { // server
	        new_entry = old_line;
	    }
	});
	return new_entry;
    });
    return netd_conf;
    }
    else {
    old_conf = maplist(`old_line, old_conf, ``{
	new_entry = old_line;
	// find all new lines for installed packages...
	if(find(old_line["iid"]:"", "inst") != -1) { // iid is beginning with "inst"
	    // find this line in new (installed) configuration
	    foreach(`new_line, netd_conf, ``{
		// service, protocol and server must be the same...
		if((new_line["service"]:"" == old_line["service"]:"!") &&         // service
		    (new_line["protocol"]:"" == old_line["protocol"]:"!") &&       // protocol
		    (find(new_line["server"]:"", select(splitstring(old_line["server"]:"!", " "), 0, "")) != -1)) { // server
		    new_line  = add(new_line, "enabled", old_line["enabled"]:true);
                    new_line  = add(new_line, "changed", true);
		    new_entry = new_line;
		}
		// else
	    });
	}
	return new_entry;
    });
    return old_conf;
    }
}

/**
 * Write all inetd settings
 * @return true on success
 */
global define boolean Write() ``{

    /* Inetd read dialog caption */
    string caption = _("Saving inetd Configuration");

    integer steps = 1;

    integer sl = 0;
    sleep(sl);

    Progress::New(caption, " ", steps, [
	    _("Write the settings"),
	], [
	    _("Writing the settings..."),
	    _("Finished")
	],
	""
    );

    y2milestone("Calling write:\n");
    // write settings
    if(Abort()) return false;
    if (write_only) {
	list new_conf = [];
	if (configured_service == `inetd) {
	    if (netd_status == 0) {
		Runlevel::ServiceAdjust("inetd", "enable");
	    }
	    else {
		Runlevel::ServiceAdjust("inetd", "disable");
	    }
	    Runlevel::ServiceAdjust("xinetd", "disable");
	    SCR::Write(.etc.inetd_conf.services, netd_conf);
	}
	else if (configured_service == `xinetd) {
	    new_conf  = SCR::Read(.etc.xinetd_conf.services);
	    netd_conf = mergeAfterInstall(new_conf, netd_conf);
	    if (netd_status == 0) {
		Runlevel::ServiceAdjust("xinetd", "enable");
	    }
	    else {
		Runlevel::ServiceAdjust("xinetd", "disable");
	    }
	    Runlevel::ServiceAdjust("inetd", "disable");
	    SCR::Write(.etc.xinetd_conf.services, netd_conf);
	}
    }
    else {
	// configured service is inetd
	if (configured_service == `inetd) {
	    // xinetd must be stopped - if installed
	    if (xinetd_installed == 0) {
		y2milestone("xinetd installed  --- stopping and disabling service");
		if (!write_only)
		    Runlevel::RunInitScript("xinetd", "stop");
		Runlevel::ServiceAdjust("xinetd", "disable");
	    }
	    else {
		y2milestone("xinetd not installed --- nothing done");
	    }
	    y2milestone("writing inetd configuration");
	    SCR::Write(.etc.inetd_conf.services, netd_conf);
	    // So, Restart service
	    if (netd_status != 0) { // want to stop
		if (inetd_status == 0) { // was running --- stop
		    y2milestone("inetd was running --- stoping and disabling service");
		    if (!write_only)
			Runlevel::RunInitScript("inetd", "stop");
		    Runlevel::ServiceAdjust("inetd", "disable");
		} // else --- leave stopped
		else {
		    y2milestone("inetd was stopped --- leaving unchanged");
		}
	    }
	    else { // want to start
		// if inetd is running - only reload
		if (inetd_status == 0) {
		    y2milestone("inetd was running --- calling force-reload");
		    if (!write_only)
			Runlevel::RunInitScript("inetd", "force-reload");
		}
		// if stopped - enable and start
		else {
		    y2milestone("inetd was stopped --- enabling and starting service");
		    Runlevel::ServiceAdjust("inetd", "enable");
		    if (!write_only)
			Runlevel::RunInitScript("inetd", "start");
		}
	    }
	}
	// configured service is xinetd
	else {
	    // inetd must be stopped - if installed
	    if (inetd_installed == 0) {
		y2milestone("inetd installed     --- stopping and disabling service");
		if (!write_only)
		    Runlevel::RunInitScript("inetd", "stop");
		Runlevel::ServiceAdjust("inetd", "disable");
	    }
	    else {
		y2milestone("inetd not installed --- nothing done");
	    }
	    y2milestone("writing xinetd cnfiguration");
	    SCR::Write(.etc.xinetd_conf.services, netd_conf);
	    // So, Restart service
	    if (netd_status != 0) { // want to stop
		if (xinetd_status == 0) {
		    y2milestone("xinetd was running --- stopping and disabling service");
		    if (!write_only)
			Runlevel::RunInitScript("xinetd", "stop");
		    Runlevel::ServiceAdjust("xinetd", "disable");
		}
		else {
		    y2milestone("xinetd was stopped --- leaving unchanged");
		}
	    }
	    else { // want to start
		// if xinetd is running - only reload
		if (xinetd_status == 0) {
		    y2milestone("xinetd was running --- calling force-reload");
		    if (!write_only)
			Runlevel::RunInitScript("xinetd", "force-reload");
		}
		// if stopped - enable and start
		else {
		    y2milestone("xinetd was stopped --- enabling and starting service");
		    Runlevel::ServiceAdjust("xinetd", "enable");
		    if (!write_only)
			Runlevel::RunInitScript("xinetd", "start");
		}
	    }
	}
    }


    y2milestone("Writting done\n");

    // in future: catch errors
    if(false) Report::Error (_("Cannot write settings!"));
    sleep(sl);

    if(Abort()) return false;
    ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    Progress::Finish();
    return true;
}

/**
 * Only Write settings
 * @return boolean True on success
 */
global define boolean WriteOnly () ``{
    write_only = true;
    return Write();
}

/**
 * merges imported changes with services defaults
 * @param changes imported changes
 * @return complete configuration with user changes
 */
global define list mergeWithDefaults(list changes) ``{
    list defaults = [];
    list new_conf = [];

    if(netd_service == `inetd) {
	defaults = default_conf_inetd["netd_conf"]:[];
    }
    else if(netd_service == `xinetd) {
	defaults = default_conf_xinetd["netd_conf"]:[];
    }

    map new_entry = nil;

    foreach(`line, changes, ``{
	// installed service (package; forEx.: bootp, amanda, ...)
	if(find(line["iid"]:"!", "inst") == 0) {
	    defaults = add(defaults, line);
	}
	//
	else if(find(line["iid"]:"!", "new") == 0) {
	    defaults = add(defaults, line);
	}
	// no `iid' means internal (or other default) service
	else if(line["iid"]:"!" == "!") {
	    defaults = maplist(`default, defaults, ``{
		if((default["server"]:""    == line["server"]:"!")   &&
		    (default["protocol"]:"" == line["protocol"]:"!") &&
		    (default["service"]:""  == line["service"]:"!")) {

		    new_entry = default;

		    foreach(`key, `val, line, ``{
			new_entry = add(new_entry, key, val);
		    });
		    new_entry = add(new_entry, "changed", true);
		}
		else {
		    new_entry = default;
		}
		return new_entry;
	    });
	}
    });
/*    foreach(`line, changes, ``{
	defaults = maplist(`default, defaults, ``{
	    if(default["iid"]:"" == line["iid"]:"!") {
		new_entry =  line;
	    }
	    else {
		new_entry = default;
	    }
	    return new_entry;
	});
    });
    foreach(`line, changes, ``{
	if((find(line["iid"]:"", "inst") != -1) &&
	    (line["created"]:false == true)) {
	    defaults = add(defaults, line);
	}
    });*/

    return defaults;
}

/**
 * Get all inetd settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
//    sleep(3000);

    // we do not want to install RPMs in autoinstallation mode...
    auto_mode = true;
    modified  = false;

    if (settings == $[])
	module_status = `not_configured;
    else
	module_status = `configured;
    /*
     * if map contains "netd_service", whole configuration is filled from this map.
     * if "netd_service" is not found, configuration is generated from default values
     * stored if default_conf_*.ycp.
     */
    // service is inetd
    if (settings["netd_service"]:`none == `inetd) {
	netd_service  = `inetd;
	inetd_conf    = mergeWithDefaults(settings["netd_conf"]:[]);
        inetd_status  = 0;
	netd_status   = settings["netd_status"]:-1;
	netd_conf     = inetd_conf;
    }
    // service is xinetd
    else if (settings["netd_service"]:`none == `xinetd) {
	netd_service  = `xinetd;
	xinetd_conf   = mergeWithDefaults(settings["netd_conf"]:[]);
        xinetd_status = 0;
	netd_status   = settings["netd_status"]:-1;
	netd_conf     = xinetd_conf;
    }
    // no service detected --- loading defaults
    else if (settings["netd_service"]:`none == `none) {
	inetd_conf    = default_conf_inetd["netd_conf"]:[];
	xinetd_conf   = default_conf_xinetd["netd_conf"]:[];
	inetd_status  = 0;
	xinetd_status = 0;
	netd_service  = `none;
    }
    // common variables
    //service_package    = settings["service_package"]:[];
    //required_packages  = settings["xinetd_packages"]:[];
    last_created       = settings["last_created"]:0;
    configured_service = netd_service;
//    required_packages  = [];
//    service_package    = [];
    return true;
}

/**
 * Get only changed entries
 * @param config complete configuration
 * @return Returnse list of changes only
 */
global define list getChanged(list config) ``{
    list defaults = [];
    list changes  = [];
    map  def_line = $[];

    if(netd_service == `inetd)
	defaults = default_conf_inetd["netd_conf"]:[];
    else
	defaults = default_conf_xinetd["netd_conf"]:[];

    // defaults not loaded --- get all services listed in config
    if(defaults == [])
	return config;

    foreach(`line, config, ``{
	if(line["changed"]:false == true) {
	    // skip new or installed services (iid is `new.*' or `inst.*')
	    string line_iid = line["iid"]:"";
	    if((find(line_iid, "new") != -1) || (find(line_iid, "inst") != -1)) {
		changes = add(changes, line);
		return; // skip the following code
	    }

	    // find coresponding entry in `defaults'
	    def_line = findiidMapinList(defaults, line_iid);

	    // def_line is empty --- possibly item not found
	    // So, write this entry into `changes'
	    if(def_line == $[]) {
		changes = add(changes, line);
		return; // skip the following code
	    }

	    // for each key in map line
	    foreach(`key, `val, line, ``{
		if((key == "protocol") || (key == "service") || (key == "server"))
		    return; // don't remove values used for identification...
		if(val == def_line[key]:"!#!")
		    line = remove(line, key);
	    });
	    if(line["unparsed"]:false != false)
		line = remove(line, "unparsed");
	    if(line["changed"]:false != false)
		line = remove(line, "changed");
/*	    if(line["comment"]:false != false)
		line = remove(line, "comment");
	    if(line["comment_inside"]:false != false)
		line = remove(line, "comment_inside");*/
	    changes = add(changes, line);
	}
    });

    y2milestone("%1", changes);
    return changes;
}

/**
 * Dump the inetd settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
//    sleep(3000);
    map config = $[];
    config = add(config, "netd_conf",       getChanged(netd_conf));
    config = add(config, "netd_service",    configured_service);
    config = add(config, "netd_status",     netd_status);
    //config = add(config, "service_package", service_package);
    //config = add(config, "xinetd_packages", required_packages);
    config = add(config, "last_created",    last_created);
    y2milestone("%1", config);
    return config;
}

/**
 * Create unsorted list of enabled services
 * @return string Returnes string with RichText-formated list
 */
global define string mkeServiceSummary() ``{
    string S = "";
    foreach(`line, netd_conf, ``{
	if((line["enabled"]:false == true) && (line["deleted"]:false == false)) {
	    S = sformat("%1<li>%2 <i>(%3, %4)</i>", S, line["service"]:"", line["socket_type"]:"", line["protocol"]:"");
	}
    });
    if(S == "")
	S = _("<p><ul><i>All services are marked as stopped.</i></ul></p>");
    return S;
}

/**
 * Create unsorted list of packages for installation
 * @return string Returnes string with RichText-formated list
 */
global define string mkePackageSummary() ``{
    string S = "";
    foreach(`line, service_package, ``{
	S = sformat("%1<li>%2", S, line);
    });
    string service = "";
    string program = "";
    foreach(`line, required_packages, ``{
	string package = select(line, 0, "");
	foreach(`pkg, xinetd_packages, ``{
	    if(pkg["package"]:"" == package) {
		service = pkg["service"]:"";
		program = pkg["program"]:"";
	    }
	});
	S = sformat("%1<li>%2 <i>(%3, %4)</i>", S, package, service, program);
    });
    return S;
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list Summary() ``{
    string S = "";
    if(module_status == `not_configured) {
	/*
	 * Translators: Summary head, if nothing configured
	 */
	S = Summary::AddHeader(S, _("Network services"));
	S = Summary::AddLine(S, Summary::NotConfigured());
    }
    else {
	/*
	 * Translators: Summary head, if something configured
	 */
	string head = sformat(_("Network services are managed via %1"),
	    configured_service == `inetd ? "inetd" : "xinetd");
	S = Summary::AddHeader(S, head);
	S = Summary::AddHeader(S, _("These services will be enabled"));
	S = sformat("%1<ul>%2</ul></p>", S, mkeServiceSummary());
	//S = Summary::AddHeader(S, _("These packages will be installed"));
	//S = sformat("%1<ul>%2</ul></p>", S, mkePackageSummary());
	/*string S = sformat(_("<p><big><b>Network services are managed via %1</b></big></p>"),
	    configured_service == `inetd ? "inetd" : "xinetd");
	S = sformat("%1<p><u>%2</u>", S, _("These services will be enabled"));
	S = sformat("%1<ul>%2</ul></p>", S, mkeServiceSummary());
	S = sformat("%1<p><u>%2</u>", S, _("These packages will be installed"));
	S = sformat("%1<ul>%2</ul></p>", S, mkePackageSummary());
	return [ S, [], ];*/
    }
    return S;
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global define list Overview() ``{
    return [];
}

/**
 * delete line in netd_conf
 * @param line_number "iid" geted from table's item ID
 */
global define void deleteLine(any line_number) ``{
    // delete
    map current_line = select(filter(`line, netd_conf,
	``(lookup(line, "iid", "0") == line_number)), 0, $[]);
    // set "deleted" flag to true
    current_line = add(current_line, "changed", true);
    current_line = add(current_line, "deleted", true);
    netd_conf    = maplist(`line, netd_conf, ``{
	if (lookup(line, "iid", "0") == line_number) {
	    return(current_line);
	}
	else {
	    return(line);
	}
    });
};

/**
 * add a line in DB
 * @param new_line new_line contains new entry for global netd_conf configuration
 * @return void
 */
global define void addLine(map new_line) ``{
    // add
    new_line  = add(new_line, "changed", true);
    netd_conf = add(netd_conf, new_line);
    return;
}

/**
 * Change a line in DB
 * @param new_line new_line contains changes for entry in netd_conf
 * @param line_number line_number contains iid of changed entry in netd_conf
 */
global define void changeLine(map new_line, any line_number) ``{
    // entry was changed - so set "changed" flag to true
    new_line  = add(new_line, "changed", true);
    netd_conf = maplist(`line, netd_conf, ``{
	if (lookup(line, "iid", "0") == line_number) {
	    return(new_line);
	}
	else {
	    return(line);
	}
    });
};

/* EOF */
}
